// Generated by CoffeeScript 1.3.3
(function() {
  var SocialReq, async, mongoose;

  mongoose = require('mongoose');

  SocialReq = require('social-request');

  async = require('async');

  module.exports = function(schema, options) {
    var SocialUserData, SocialUserDataSchema, socialReq, _findOrCreateUser;
    SocialUserDataSchema = new mongoose.Schema({
      _user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: options.userModel || 'User'
      },
      facebook: {
        userData: {},
        contacts: Array
      },
      twitter: {
        userData: {},
        contacts: Array
      },
      google: {
        userData: {},
        contacts: Array
      },
      googleplus: {
        userData: {},
        contacts: Array
      }
    });
    if ((options != null ? options.connection : void 0) == null) {
      throw new Error('No connection supplied, set options.connection in plugin definition');
    }
    SocialUserData = options.connection.model('SocialUserData', SocialUserDataSchema);
    socialReq = new SocialReq();
    socialReq.use('google', {
      clientId: options.google.clientId,
      clientSecret: options.google.clientSecret
    }).use('googleplus', {
      clientId: options.google.clientId,
      clientSecret: options.google.clientSecret
    }).use('facebook', {
      appId: options.facebook.appId,
      appSecret: options.facebook.appSecret
    });
    schema.add({
      auth: {
        facebook: {
          id: String,
          username: String,
          aT: String,
          createdAt: Date
        },
        twitter: {
          id: String,
          username: String,
          aT: String,
          aTS: String,
          createdAt: Date
        },
        google: {
          id: String,
          username: String,
          aT: String,
          rT: String,
          createdAt: Date
        },
        googleplus: {
          id: String,
          username: String,
          aT: String,
          rT: String,
          createdAt: Date
        }
      }
    });
    _findOrCreateUser = function(params, done) {
      var self, upsertSocialIdToDatabase, userParams, _ref, _ref1;
      if (!params.service || !params.session || !params.data) {
        return done(new Error("couldn't log you in"));
      }
      self = this;
      upsertSocialIdToDatabase = function(user, newUser, done) {
        user.auth[params.service].id = params.data.id;
        user.auth[params.service].username = params.data.username;
        if (newUser) {
          user.auth[params.service].createdAt = new Date();
        }
        user.auth[params.service].aT = params.data.aT;
        if (params.data.rT != null) {
          user.auth[params.service].rT = params.data.rT;
        }
        user.auth[params.service].aTS = params.data.aTS;
        return async.waterfall([
          function(cb) {
            return SocialUserData.findOne({
              _user: user._id
            }, cb);
          }, function(socialUserData, cb) {
            if (!(socialUserData != null)) {
              socialUserData = new SocialUserData({
                _user: user._id
              });
              return socialUserData.save(cb);
            } else {
              return cb(null, socialUserData);
            }
          }
        ], function(err, socialUserData) {
          var param, _ref;
          if (err) {
            return done(err);
          }
          if (!(((_ref = socialUserData[params.service]) != null ? _ref.userData : void 0) != null)) {
            socialUserData[params.service].userData = params.data;
          } else {
            for (param in params.data) {
              socialUserData[params.service].userData[param] = params.data[param];
            }
            socialUserData.markModified(params.service + '.userData');
          }
          return async.parallel({
            user: function(cb) {
              return user.save(cb);
            },
            socialUserData: function(cb) {
              return socialUserData.save(cb);
            }
          }, function(err, results) {
            return done(err, user, newUser);
          });
        });
      };
      userParams = {};
      userParams['auth.' + params.service + '.id'] = params.data.id;
      if (((_ref = params.session) != null ? (_ref1 = _ref.auth) != null ? _ref1.userId : void 0 : void 0) != null) {
        return this.findById(params.session.auth.userId, function(err, user) {
          if (err) {
            return done(err, null);
          }
          if (!(user != null)) {
            return done(null);
          }
          return self.findOne(userParams, function(err, occupyingUser) {
            if ((err != null) || (occupyingUser && occupyingUser.id !== params.session.auth.userId)) {
              return done(err != null ? err : new Error('Another user has already linked this account'));
            }
            return upsertSocialIdToDatabase(user, false, done);
          });
        });
      } else {
        return this.findOne(userParams, function(err, user) {
          if (err) {
            return done(err, null);
          }
          if (user != null) {
            return upsertSocialIdToDatabase(user, false, done);
          }
          return self.create({}, function(err, user) {
            return upsertSocialIdToDatabase(user, true, done);
          });
        });
      }
    };
    schema.statics.findOrCreateUser = function(service) {
      var self;
      self = this;
      switch (service) {
        case 'googlehybrid':
          return function(session, userAttributes) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "google",
              session: session,
              data: userAttributes
            };
            params.data.id = params.data.claimedIdentifier.split('=')[1];
            params.data.username = params.data.email;
            params.data.userData = {
              email: params.data.email,
              firstname: params.data.firstname,
              lastname: params.data.lastname
            };
            params.data.aT = params.data.access_token;
            params.data.aTS = params.data.access_token_secret;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
        case 'google':
          return function(session, accessToken, accessTokExtra, userAttributes) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "google",
              session: session,
              data: userAttributes
            };
            params.data.username = params.data.email;
            params.data.aT = accessToken;
            if (accessTokExtra.refresh_token != null) {
              params.data.rT = accessTokExtra.refresh_token;
            }
            params.data.aTE = accessTokExtra;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
        case 'facebook':
          return function(session, accessToken, accessTokExtra, fbUserMetaData) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "facebook",
              session: session,
              data: fbUserMetaData
            };
            params.data.aT = accessToken;
            params.data.aTE = accessTokExtra;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
      }
    };
    schema.methods._socialReqGet = function(params, cb) {
      var self;
      self = this;
      socialReq.getTokens(function(id, cb) {
        return cb({
          facebook: {
            access_token: self.auth.facebook.aT
          },
          google: {
            access_token: self.auth.google.aT,
            refresh_token: self.auth.google.rT
          },
          googleplus: {
            access_token: self.auth.google.aT
          }
        });
      });
      return socialReq.get(this.id, params, cb);
    };
    schema.methods.getSocial = function(params, done) {
      var self;
      self = this;
      return self._socialReqGet(params, function(err, results) {
        var processingFunctions, removeServiceFromSecondTryParams, requestType, secondTry, secondTryParams, secondTryServices, service, setErrorsForService;
        if (err) {
          return done(err);
        }
        processingFunctions = [];
        secondTry = false;
        secondTryParams = {};
        secondTryServices = [];
        for (requestType in results) {
          for (service in results[requestType]) {
            if (results[requestType][service].error != null) {
              secondTry = true;
              if (secondTryParams[requestType] == null) {
                secondTryParams[requestType] = [];
              }
              secondTryParams[requestType].push(service);
              if (secondTryServices.indexOf(service) === -1) {
                secondTryServices.push(service);
              }
            }
          }
        }
        removeServiceFromSecondTryParams = function(service) {
          var i, _results;
          _results = [];
          for (requestType in secondTryParams) {
            i = secondTryParams[requestType].indexOf(service);
            if (i !== -1) {
              secondTryParams[requestType].splice(i, 1);
            }
            if (Object.keys(secondTryParams[requestType]).length === 0) {
              _results.push(delete secondTryParams[requestType]);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        setErrorsForService = function(service, err) {
          var resultService, _results;
          _results = [];
          for (requestType in results) {
            _results.push((function() {
              var _results1;
              _results1 = [];
              for (resultService in results[requestType]) {
                if (resultService === service) {
                  _results1.push(results[requestType][service].error = err);
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          }
          return _results;
        };
        return async.waterfall([
          function(cb) {
            if (!secondTry) {
              return cb();
            }
            return async.forEach(secondTryServices, function(service, cb) {
              if (service === 'google') {
                return self._refreshAccessToken(service, function(err, user) {
                  if (err) {
                    removeServiceFromSecondTryParams(service);
                    setErrorsForService(service, err);
                  }
                  return cb();
                });
              } else if (service === 'googleplus') {
                return self._refreshAccessToken('google', function(err, user) {
                  if (err) {
                    removeServiceFromSecondTryParams(service);
                    setErrorsForService(service, err);
                  }
                  return cb();
                });
              } else if (service === 'facebook') {
                removeServiceFromSecondTryParams(service);
                return cb();
              } else {
                removeServiceFromSecondTryParams(service);
                return cb();
              }
            }, function(err) {
              if (err) {
                return cb(err);
              }
              if (Object.keys(secondTryParams).length === 0) {
                return cb();
              }
              return self._socialReqGet(secondTryParams, function(err, secondResults) {
                if (err) {
                  return cb(err);
                }
                for (requestType in secondResults) {
                  for (service in secondResults[requestType]) {
                    results[requestType][service] = secondResults[requestType][service];
                  }
                }
                return cb();
              });
            });
          }
        ], function(err) {
          if (err) {
            return done(err);
          }
          return async.waterfall([
            function(cb) {
              return SocialUserData.findOne({
                _user: self._id
              }, cb);
            }, function(socialUserData, cb) {
              if (!(socialUserData != null)) {
                socialUserData = new SocialUserData({
                  _user: self._id
                });
                return socialUserData.save(cb);
              } else {
                return cb(null, socialUserData);
              }
            }
          ], function(err, socialUserData) {
            var param;
            if (err) {
              return done(err);
            }
            for (requestType in results) {
              switch (requestType) {
                case 'contacts':
                  for (service in results.contacts) {
                    if (results.contacts[service].error == null) {
                      processingFunctions.push(function(cb) {
                        return async.filter(results.contacts[service], function(contact, cb) {
                          switch (service) {
                            case 'google':
                              return cb(contact.email != null);
                            default:
                              return cb(true);
                          }
                        }, function(contacts) {
                          return async.sortBy(contacts, function(contact, cb) {
                            var _ref;
                            return cb(null, (_ref = contact.entry.gd$name) != null ? _ref.gd$familyName : void 0);
                          }, function(err, contacts) {
                            if (err) {
                              done(err);
                            }
                            if (!socialUserData[service]) {
                              socialUserData[service] = {};
                            }
                            socialUserData[service].contacts = results.contacts[service] = contacts;
                            return cb();
                          });
                        });
                      });
                    }
                  }
                  break;
                case 'details':
                  for (service in results.details) {
                    if (results.details[service].error == null) {
                      if (!(socialUserData[service].userData != null)) {
                        socialUserData[service].userData = results.details[service];
                      } else {
                        for (param in results.details[service]) {
                          socialUserData[service].userData[param] = results.details[service][param];
                        }
                        socialUserData.markModified(service + '.userData');
                      }
                    }
                  }
              }
            }
            return async.parallel(processingFunctions, function(err, processingResults) {
              if (err) {
                return done(err);
              }
              return async.parallel({
                user: function(cb) {
                  return self.save(cb);
                },
                socialUserData: function(cb) {
                  return socialUserData.save(cb);
                }
              }, function(err, models) {
                return done(err, results);
              });
            });
          });
        });
      });
    };
    /*
      schema.on 'init', (model) ->
        socialReq.getTokens (id, cb) ->
          model.findById id, (err, user) ->
            return cb(err || new Error 'User does not exist') if err? or not user?
            cb
              facebook:
                access_token: user.auth.facebook.aT
              google: 
                access_token: user.auth.google.aT
                access_token_secret: user.auth.google.aTS
    */

    schema.methods._invalidateAccessToken = function(service, done) {
      if (!(this.auth[service] != null)) {
        return done(null, this);
      }
      this.auth[service].aT = void 0;
      this.auth[service].aTS = void 0;
      return this.save(done);
    };
    schema.methods._refreshAccessToken = function(service, done) {
      var self;
      if (!(this.auth[service] != null)) {
        return done(null, this);
      }
      if (!(this.auth[service].rT != null)) {
        return done(new Error('No refresh token for service ' + service + ', user needs to be redirected to authentication screen'));
      }
      self = this;
      socialReq.getTokens(function(id, cb) {
        return cb({
          facebook: {
            access_token: self.auth.facebook.aT
          },
          google: {
            access_token: self.auth.google.aT,
            refresh_token: self.auth.google.rT
          },
          googleplus: {
            access_token: self.auth.google.aT
          }
        });
      });
      return socialReq.get(this.id, {
        tokens: [service]
      }, function(err, results) {
        var _ref;
        if (err || !(((_ref = results.tokens[service]) != null ? _ref.access_token : void 0) != null)) {
          done(err || new Error('Token refresh failed for some reason'));
        }
        self.auth.google.aT = results.tokens[service].access_token;
        return self.save(done);
      });
    };
  };

}).call(this);
