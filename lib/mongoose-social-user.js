// Generated by CoffeeScript 1.3.3
(function() {
  var SocialReq, async, mongoose;

  mongoose = require('mongoose');

  SocialReq = require('social-request');

  async = require('async');

  module.exports = function(schema, options) {
    var socialReq, _findOrCreateUser;
    socialReq = new SocialReq();
    socialReq.use('google', {
      clientId: options.google.clientId,
      clientSecret: options.google.clientSecret
    }).use('googleplus', {
      clientId: options.google.clientId,
      clientSecret: options.google.clientSecret
    }).use('facebook', {
      appId: options.facebook.appId,
      appSecret: options.facebook.appSecret
    });
    schema.add({
      auth: {
        facebook: {
          id: String,
          username: String,
          aT: String,
          createdAt: Date,
          userData: {},
          contacts: Array
        },
        twitter: {
          id: String,
          username: String,
          aT: String,
          aTS: String,
          createdAt: Date,
          userData: {},
          contacts: Array
        },
        google: {
          id: String,
          username: String,
          aT: String,
          aTS: String,
          createdAt: Date,
          userData: {},
          contacts: Array
        },
        googleplus: {
          id: String,
          username: String,
          aT: String,
          aTS: String,
          createdAt: Date,
          userData: {},
          contacts: Array
        }
      }
    });
    _findOrCreateUser = function(params, done) {
      var self, upsertSocialIdToDatabase, userParams, _ref, _ref1;
      if (!params.service || !params.session || !params.data) {
        return done(new Error("couldn't log you in"));
      }
      self = this;
      upsertSocialIdToDatabase = function(user, newUser, done) {
        var param;
        user.auth[params.service].id = params.data.id;
        user.auth[params.service].username = params.data.username;
        if (newUser) {
          user.auth[params.service].createdAt = new Date();
        }
        user.auth[params.service].aT = params.data.aT;
        user.auth[params.service].aTS = params.data.aTS;
        if (!(user.auth[params.service].userData != null)) {
          user.auth[params.service].userData = params.data;
        } else {
          for (param in params.data) {
            user.auth[params.service].userData[param] = params.data[param];
          }
          user.markModified('auth.' + params.service + '.userData');
        }
        return user.save(function(err) {
          return done(err, user, newUser);
        });
      };
      userParams = {};
      userParams['auth.' + params.service + '.id'] = params.data.id;
      if (((_ref = params.session) != null ? (_ref1 = _ref.auth) != null ? _ref1.userId : void 0 : void 0) != null) {
        return this.findById(params.session.auth.userId, function(err, user) {
          if (err) {
            return done(err, null);
          }
          if (!(user != null)) {
            return done(null);
          }
          return self.findOne(userParams, function(err, occupyingUser) {
            if ((err != null) || (occupyingUser && occupyingUser.id !== params.session.auth.userId)) {
              return done(err != null ? err : new Error('Another user has already linked this account'));
            }
            return upsertSocialIdToDatabase(user, false, done);
          });
        });
      } else {
        return this.findOne(userParams, function(err, user) {
          if (err) {
            return done(err, null);
          }
          if (user != null) {
            return upsertSocialIdToDatabase(user, false, done);
          }
          return self.create({}, function(err, user) {
            return upsertSocialIdToDatabase(user, true, done);
          });
        });
      }
    };
    schema.statics.findOrCreateUser = function(service) {
      var self;
      self = this;
      switch (service) {
        case 'googlehybrid':
          return function(session, userAttributes) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "google",
              session: session,
              data: userAttributes
            };
            params.data.id = params.data.claimedIdentifier.split('=')[1];
            params.data.username = params.data.email;
            params.data.userData = {
              email: params.data.email,
              firstname: params.data.firstname,
              lastname: params.data.lastname
            };
            params.data.aT = params.data.access_token;
            params.data.aTS = params.data.access_token_secret;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
        case 'google':
          return function(session, accessToken, accessTokExtra, userAttributes) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "google",
              session: session,
              data: userAttributes
            };
            params.data.username = params.data.email;
            params.data.aT = accessToken;
            params.data.aTE = accessTokExtra;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
        case 'facebook':
          return function(session, accessToken, accessTokExtra, fbUserMetaData) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "facebook",
              session: session,
              data: fbUserMetaData
            };
            params.data.aT = accessToken;
            params.data.aTE = accessTokExtra;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
      }
    };
    schema.methods.getSocial = function(params, done) {
      var self;
      self = this;
      socialReq.getTokens(function(id, cb) {
        return cb({
          facebook: {
            access_token: self.auth.facebook.aT
          },
          google: {
            access_token: self.auth.google.aT
          },
          googleplus: {
            access_token: self.auth.google.aT
          }
        });
      });
      return socialReq.get(this.id, params, function(err, results) {
        var param, processingFunctions, requestType, service;
        processingFunctions = [];
        for (requestType in results) {
          switch (requestType) {
            case 'contacts':
              for (service in results.contacts) {
                if (results.contacts[service].error == null) {
                  processingFunctions.push(function(cb) {
                    return async.filter(results.contacts[service], function(contact, cb) {
                      return cb(contact.email != null);
                    }, function(contacts) {
                      return async.sortBy(contacts, function(contact, cb) {
                        var _ref;
                        return cb(null, (_ref = contact.entry.gd$name) != null ? _ref.gd$familyName : void 0);
                      }, function(err, contacts) {
                        self.auth[service].contacts = results.contacts[service] = contacts;
                        return cb();
                      });
                    });
                  });
                }
              }
              break;
            case 'details':
              for (service in results.details) {
                if (results.details[service].error == null) {
                  if (!(self.auth[service].userData != null)) {
                    self.auth[service].userData = results.details[service];
                  } else {
                    for (param in results.details[service]) {
                      self.auth[service].userData[param] = results.details[service][param];
                    }
                    self.markModified('auth.' + service + '.userData');
                  }
                }
              }
          }
        }
        return async.parallel(processingFunctions, function(err, processingResults) {
          if (err) {
            return done(err);
          }
          return self.save(function(err) {
            return done(err, results);
          });
        });
      });
    };
    /*
      schema.on 'init', (model) ->
        socialReq.getTokens (id, cb) ->
          model.findById id, (err, user) ->
            console.log err, user
            return cb(err || new Error 'User does not exist') if err? or not user?
            cb
              facebook:
                access_token: user.auth.facebook.aT
              google: 
                access_token: user.auth.google.aT
                access_token_secret: user.auth.google.aTS
    */

    schema.methods._invalidateAT = function(service, done) {
      if (!(this.auth[service] != null)) {
        return done(null, this);
      }
      this.auth[service].aT = void 0;
      this.auth[service].aTS = void 0;
      return this.save(done);
    };
  };

}).call(this);
